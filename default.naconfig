# This is the default configuration file for the architecture.
# Parameters are specified in this file, then checked for correctness in
# pynabp/conf_gen.py.

debug = True

config = \
    {
        # Run the architecture in debug mode.
        # This yields unsynthesisable statements for testing purposes.
        # Constraints:
        #   True / False
        'debug': debug,

        # Test goals.
        # This specifies what functionalities are tested.
        # Constraints:
        # A valid list of strings, each string represents a valid functionality
        # test. FIXME currently these test goals are buried deep within the
        # project, need to find a way to explicitly outline these.
        'target': [
                'domino_test',
                'reconstruction_test',
                # 'processing_verify',
                ],

        # Simulation clock period.
        # The clock period used for simulation, in nanoseconds.
        # Constraints:
        #   Positive values. Precisions will be limited by the precision of
        #   simulation timing.
        'clock_period': 20.0,

        # Simulation timing precision.
        # The precision various simulator will try to conform (and often fails
        # to do so).
        # Constraints:
        #    Integer followed by a valid time unit, e.g. ns, ps and etc..
        'time_precision': '10ps',

        # The targeted device.
        # This setting will have no effect and defaults to 'simulator' if the
        # debug mode toggle is set. There are parts of the architecture that
        # cannot be generic, such as the filter module.
        # Constraints:
        #   A string specifying a valid device. The device string must be valid
        #   for release builds.
        'device': 'simulator' if debug else 'stratix_iv',

        # How wide the projection line is.
        # If not specified, then it defaults to the nearest integer value of
        # image_size * sqrt(2)
        # Constraints:
        #   Value must be a positive integer
        'projection_line_size': None,

        # The image size.
        # If not specified, then it defaults to the nearest integer value of
        # projection_line_size / sqrt(2)
        # Constraints:
        #   Value must be a positive integer
        'image_size': 127,

        # Filter order.
        # Constraints:
        #   Value must be a positive even integer
        'fir_order': 64,

        # Filter function.
        # If not specified, it defaults to the filter generated by sampling the
        # ideal ramp filter.
        # Constraints:
        #   The function will be called with fir_order as its only argument.
        #   It must return a list containing all coefficients. Currently the
        #   architecture only allows FIR filtering, although IIR is easy to
        #   adopt.
        'fir_function': None,

        # No of processing elements.
        # Constraints:
        #   The hardware resources available (will only know after place &
        #   route). Value should not be greater than the width of the image,
        #   value should also be sensible enough to ensure no processing
        #   elements are doing work for wasted pixels only (validator will
        #   check for this).
        #   FIXME In this new implementation, this value must equal to image
        #   size. Future implementations will incorporate concurrent
        #   subdivision to allow further increase of the value.
        'no_of_processing_elements': 127,

        # The angle step size.
        # This determines the difference of angle values between two projection
        # lines in a sinogram where the angles are evenly distributed. If it is
        # not given, then the angle step size is derived from kAnglePrecision.
        # The sinogram data must conform to this step size constraint, that is,
        # the data address for sinogram $g(\theta, s)$ is given by
        #       $p\theta+s$,
        # where $p$ is the projection line size, $\theta$ is the angle value
        # and $s$ is the projection offset.
        # Constraints:
        #   Positive numbers.
        'angle_step_size': None if not debug else 10,

        # The bit length of the data representation for a single projection
        # data point.
        # Constraints:
        #   Positive integers.
        'kDataLength': 10,

        # The decimal places (in binary) of data after filtering appended.
        # TODO actually make use of this precision.
        # Constraints:
        #   Natural integers.
        'kFilteredDataPrecision': 3,

        # The decimal places (in binary) of the angles' representation
        # precision.
        # TODO actually make use of this precision.
        # Constraints:
        #   Natural integers.
        'kAnglePrecision': 0,

        # The decimal places (in binary) of shifter's accumulating
        # multiplicand and accumulator.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        'kShiftAccuPrecision': 30,

        # The decimal places (in binary) of mapper's accumulating multiplicand.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        'kMapAccuPrecision': 30,

        # Force assignment of values of parameters.
        # The forced parameters will be used to override the parameters after
        # configuration validation and generation. Using this is unsafe, and
        # does not guarantee correct simulation behaviour. This should only be
        # allowed to bypass some sanity checks to obtain accurate synthesis
        # results.
        # The corresponding values will be updated recursively.
        # Constraints:
        #   None value or a dictionary.
        'force': None,
    }

# vim: ft=python:
