# This is the default configuration file for the architecture.
# Parameters are specified in this file, then checked for correctness in
# pynabp/conf.py.

config = \
    {
        # Run the architecture in debug mode.
        # This yields unsynthesisable statements for testing purposes.
        # Constraints:
        #   True / False
        'debug': True,

        # Simulation clock period.
        # The clock period used for simulation, in nanoseconds.
        # Constraints:
        #   Positive values. Precisions will be limited by the precision of
        #   simulation timing.
        'clock_period': 20,

        # Simulation timing precision.
        # The precision various simulator will try to conform (and often fails
        # to do so).
        # Constraints:
        #    Integer followed by a valid time unit, e.g. ns, ps and etc..
        'time_precision': '10ps',

        # The targeted device.
        # Reserved for future purposes.
        # Constraints:
        #   A string specifying a valid device.
        'device': None,

        # How wide the projection line is.
        # Constraints:
        #   Value must be an odd number to calculate an integer valued center
        'projection_line_size': 361,

        # The image size.
        # If not specified, then it defaults to the nearest odd valued
        # projection_line_size / sqrt(2)
        # Constraints:
        #   Value must be an odd number to calculate an integer valued center
        'image_size': None,

        # Filter order.
        # Constraints:
        #   Value must be a positive even integer
        'fir_order': 64,

        # Filter function.
        # If not specified, it defaults to the filter generated by sampling the
        # ideal ramp filter.
        # Constraints:
        #   If fir_order is specifed, then the function will be called with
        #   fir_order as its only argument, otherwise it will be called with
        #   no arguments. It must return a list containing all coefficients.
        #   Currently the architecture only allows FIR filtering, although IIR
        #   is easy to adopt.
        'fir_function': None,

        # No of processing elements.
        # Constraints:
        #   The hardware resources available (will only know after place &
        #   route). Value should not be greater than the width of the image,
        #   value should also be sensible enough to ensure no processing
        #   elements are doing work for wasted pixels only (validator will
        #   check for this).
        'no_of_processing_elements': 20,

        # The bit length of the data representation for a single projection
        # data point.
        # Constraints:
        #   Positive integers.
        'kDataLength': 8,

        # The decimal places (in binary) of data after filtering.
        # Constraints:
        #   Natural integers.
        'kFilteredDataPrecision': 3,

        # The decimal places (in binary) of the angles' representation
        # precision.
        # Constraints:
        #   Natural integers.
        'kAnglePrecision': 0,

        # The decimal places (in binary) of shifter's accumulating
        # multiplicand and accumulator.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        'kShiftAccuPrecision': 12,

        # The decimal places (in binary) of mapper's accumulating multiplicand.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        #   Greater than or equal to kMapAccuPartPrecision
        'kMapAccuPrecision': 12,

        # The decimal places (in binary) of mapper's accumulator's initial
        # value.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        #   Less than or equal to kMapAccuPrecision
        'kMapAccuPartPrecision': 8,
    }
# vim: ft=python:
