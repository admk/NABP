# This is the default configuration file for the architecture.
# Parameters are specified in this file, then checked for correctness in
# pynabp/conf_gen.py.

debug = True

config = \
    {
        # Run the architecture in debug mode.
        # This yields unsynthesisable statements for testing purposes.
        # Constraints:
        #   True / False
        'debug': debug,

        # Simulation clock period.
        # The clock period used for simulation, in nanoseconds.
        # Constraints:
        #   Positive values. Precisions will be limited by the precision of
        #   simulation timing.
        'clock_period': 20.0,

        # Simulation timing precision.
        # The precision various simulator will try to conform (and often fails
        # to do so).
        # Constraints:
        #    Integer followed by a valid time unit, e.g. ns, ps and etc..
        'time_precision': '10ps',

        # The targeted device.
        # This setting will have no effect and defaults to 'simulator' if the
        # debug mode toggle is set. There are parts of the architecture that
        # cannot be generic, such as the filter module.
        # Constraints:
        #   A string specifying a valid device. The device string must be valid
        #   for release builds.
        'device': None,

        # How wide the projection line is.
        # Constraints:
        #   Value must be an odd number to calculate an integer valued center
        'projection_line_size': 179,

        # The image size.
        # If not specified, then it defaults to the nearest odd valued
        # projection_line_size / sqrt(2)
        # Constraints:
        #   Value must be an odd number to calculate an integer valued center
        'image_size': None,

        # Filter order.
        # Constraints:
        #   Value must be a positive even integer
        'fir_order': 64,

        # Filter function.
        # If not specified, it defaults to the filter generated by sampling the
        # ideal ramp filter.
        # Constraints:
        #   The function will be called with fir_order as its only argument.
        #   It must return a list containing all coefficients. Currently the
        #   architecture only allows FIR filtering, although IIR is easy to
        #   adopt.
        'fir_function': None,

        # No of processing elements.
        # Constraints:
        #   The hardware resources available (will only know after place &
        #   route). Value should not be greater than the width of the image,
        #   value should also be sensible enough to ensure no processing
        #   elements are doing work for wasted pixels only (validator will
        #   check for this).
        'no_of_processing_elements': 20,

        # The angle step size.
        # This determines the difference of angle values between two projection
        # lines in a sinogram where the angles are evenly distributed. If it is
        # not given, then the angle step size is derived from kAnglePrecision.
        # The sinogram data must conform to this step size constraint, that is,
        # the data address for sinogram $g(\theta, s)$ is given by
        #       $p\theta+s$,
        # where $p$ is the projection line size, $\theta$ is the angle value
        # and $s$ is the projection offset.
        # Constraints:
        #   Positive numbers.
        'angle_step_size': None if not debug else 10,

        # The bit length of the data representation for a single projection
        # data point.
        # Constraints:
        #   Positive integers.
        'kDataLength': 10,

        # The decimal places (in binary) of data after filtering appended.
        # TODO actually make use of this precision.
        # Constraints:
        #   Natural integers.
        'kFilteredDataPrecision': 3,

        # The decimal places (in binary) of the angles' representation
        # precision.
        # TODO actually make use of this precision.
        # Constraints:
        #   Natural integers.
        'kAnglePrecision': 0,

        # The decimal places (in binary) of shifter's accumulating
        # multiplicand and accumulator.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        'kShiftAccuPrecision': 12,

        # The decimal places (in binary) of mapper's accumulating multiplicand.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        #   Greater than or equal to kMapAccuPartPrecision
        'kMapAccuPrecision': 12,

        # The decimal places (in binary) of mapper's accumulator's initial
        # value.
        # This is used to generate a LUT in which values are of this precision.
        # Constraints:
        #   Positive integers.
        #   Less than or equal to kMapAccuPrecision
        'kMapAccuPartPrecision': 8,
    }

# vim: ft=python:
